use std::collections::HashMap;
use unity_random::Random;

#[test]
fn on_unit_sphere() {
    let mut random = Random::new();

    let mut map: HashMap<i32, [(f32, f32, f32); 5]> = HashMap::new();
    map.insert(
        0,
        [
            (-0.8513461, 0.4968821, -0.1682793),
            (0.09708977, 0.9327465, -0.3472139),
            (-0.5418345, 0.744557, 0.3899362),
            (-0.9522503, 0.01097478, -0.3051211),
            (0.5954313, -0.6745495, 0.4363994),
        ],
    );
    map.insert(
        1,
        [
            (0.005392162, 0.03509618, -0.9993694),
            (-0.9035649, -0.2292374, -0.3619677),
            (0.2129496, 0.9586377, -0.1888548),
            (0.3638166, -0.4251846, -0.8287675),
            (-0.8200869, 0.3017466, 0.4862165),
        ],
    );
    map.insert(
        358118,
        [
            (0.5660996, -0.7560467, -0.328519),
            (-0.4399648, 0.2903598, -0.8497777),
            (0.03525296, 0.4134798, -0.9098306),
            (0.9403212, -0.3402691, -0.003598809),
            (0.6622385, -0.04389393, -0.7480063),
        ],
    );
    map.insert(
        30029247,
        [
            (-0.9811152, 0.06419647, 0.1824607),
            (-0.2894619, -0.5522277, -0.7818289),
            (-0.3118641, -0.5757556, 0.7558084),
            (-0.007185814, -0.9499767, -0.3122381),
            (0.6519667, -0.4001966, -0.6440358),
        ],
    );
    map.insert(
        719188662,
        [
            (0.3084782, -0.8352942, 0.4551096),
            (0.380973, -0.1426206, -0.9135201),
            (-0.1692309, -0.7585462, 0.6292603),
            (0.7641817, -0.5671062, -0.3072733),
            (-0.9755156, 0.2162906, 0.03984559),
        ],
    );

    for (seed, values) in map {
        random.init_state(seed);

        for point in values {
            let result = random.on_unit_sphere();

            assert!((point.0 - result.0).abs() < f32::EPSILON);
            assert!((point.1 - result.1).abs() < f32::EPSILON);
            assert!((point.2 - result.2).abs() < f32::EPSILON);
        }
    }
}
