use std::collections::HashMap;
use unity_random::Random;

#[test]
fn color() {
    let mut random = Random::new();

    let mut map: HashMap<i32, [(f32, f32, f32, f32); 5]> = HashMap::new();
    map.insert(
        0,
        [
            (0.280165, 0.4749825, 0.6736069, 1.),
            (0.3004897, 0.6525605, 0.2284767, 1.),
            (0.7968054, 0.8786913, 0.7601538, 1.),
            (0.3509818, 0.1626486, 0.7036801, 1.),
            (0.08609357, 0.1192326, 0.1104441, 1.),
        ],
    );
    map.insert(
        1,
        [
            (0.6809838, 0.1537234, 0.154721, 1.),
            (0.196785, 0.5078177, 0.9143838, 1.),
            (0.5467726, 0.7822797, 0.3472435, 1.),
            (0.8054585, 0.9611027, 0.9237908, 1.),
            (0.213082, 0.03698648, 0.1664121, 1.),
        ],
    );
    map.insert(
        358118,
        [
            (0.7882738, 0.7902469, 0.9248888, 1.),
            (0.5017994, 0.1186571, 0.2223003, 1.),
            (0.06857181, 0.06784951, 0.06839556, 1.),
            (0.3420682, 0.262748, 0.1026809, 1.),
            (0.01721895, 0.003138969, 0.009349328, 1.),
        ],
    );
    map.insert(
        30029247,
        [
            (0.4361926, 0.8909144, 0.6420079, 1.),
            (0.656119, 0.5983906, 0.440251, 1.),
            (0.2906891, 0.2668063, 0.2924286, 1.),
            (0.5519958, 0.4233186, 0.676761, 1.),
            (0.06959277, 0.6046725, 0.08519226, 1.),
        ],
    );
    map.insert(
        719188662,
        [
            (0.8391423, 0.95676, 0.7714394, 1.),
            (0.6327364, 0.6536366, 0.4673925, 1.),
            (0.3116113, 0.669737, 0.6269278, 1.),
            (0.5848266, 0.4089689, 0.3408057, 1.),
            (0.1604744, 0.006180897, 0.1903621, 1.),
        ],
    );

    for (seed, values) in map {
        random.init_state(seed);

        for color in values {
            let result = random.color();

            // color_hsv may produce inaccurate results due to donet versions below 5.x
            // `values` come straight from Unity, not from dotnet 5.x
            assert!((color.0 - result.0).abs() <= f32::EPSILON);
            assert!((color.1 - result.1).abs() <= f32::EPSILON);
            assert!((color.2 - result.2).abs() <= f32::EPSILON);
            assert!((color.3 - result.3).abs() <= f32::EPSILON);
        }
    }
}
